---
title: "LBL: Logistic Bayesian LASSO for Detecting Rare Haplotype Associations"
author: "Meng Wang"
date: "`r Sys.Date()`"
eval: false
header-includes:
  - \usepackage{hyperref}
  - \hypersetup{colorlinks = true, linkcolor = blue, urlcolor = blue}
output:
  pdf_document:
    toc: yes
    toc_depth: 2
    number_sections: yes
    highlight: tango
bibliography: bibliography.bib
csl: the-american-journal-of-human-genetics.csl
link-citations: true
vignette: >
  %\VignetteIndexEntry{LBL}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
---

<!-- Center titles -->
<style type="text/css">

h1.title {
  text-align: center;
}
h4.author { /* Header 4 - and the author and data headers use this too  */
  font-size: 20px;
  text-align: center;
}
h4.date { /* Header 4 - and the author and data headers use this too  */
  font-size: 20px;
  text-align: center;
}
</style>


```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)

```

# Introduction

LBL (Logistic Bayesian LASSO) (@biswas2012logistic, @wang2014famlbl) is a group of Bayesian genetic association tests aimed at detecting association between rare *haplotypes* (which can be formed by common or rare SNPs) and diseases. Currently there are three different LBLs that handle different types of study design: LBL for independent case-control data (@biswas2012logistic), famLBL for case-parent triad (family trio) data (@wang2014famlbl) and cLBL for a combination of data from the two designs. All three LBLs take genotype data as input, impute haplotype distribution for each individual, run an MCMC algorithm, and then provide statistical inferences of the effect of each haplotype based on the posterior samples.

<!--Analysis with rare haplotypes can provide additional insight into the mechanism of diseases, but it is more difficult to model and study their effects due to the difficulties in obtaining accurate haplotypes, either via direct haplotyping or imputation, and numerical instability to deal with near 0 frequencies. -->

The rest of the vignette is structured as follows:

- [Methods] section provides some technical details about the algorithm. Users can skip this section.
- [Using LBL] section provides some detailed instruction of how to use the program.
- [Example] section has a step-by-step guide of applying LBL to a simulated dataset.


# Methods

In this section, we provide a short description of the LBL methodology. LBL methods are based on hierachical Bayesian models. The likelihood portions of all LBL methods are formulated with retrsopective likelihoods of probability of haplotypes given disease status. This likelihood is then connected to disease model via a logistic link. The priors of LBL methods include a double exponential distribution on $\beta$, the haplotypic effect. A Laplace prior exerts a penalty on the coefficient esitmates of non-associated haplotypes, allowing the associated haplotypes (such as the rare haplotypes with larger effect size) to stand out in the association analysis. This procedure provides similar results as the frequentist LASSO (@lasso) regression. The prior distributions for other parameters are specfied below. Monte Carlo Markov Chain algorithm (MCMC, @mcmc) is used for computing posterior samples when the posterior distribution cannot be derived analytically.

LBL methods also treat the real (often unknown) haplotype of an individual as a hyperparameter. In case the haplotype of an individual cannot be uniquely ascertained, then in each iteration, the haplotype is sampled based on the conditional distribution of haplotypes. Compared to haplotype imputation, this approach is more accurate in assessing haplotypes. The sample space of haplotypes of a dataset is obtained with code from package [hapassoc](http://stat.sfu.ca/statgen/research/hapassoc.html).

In the next section we will discuss the likelihoods formulation, the priors, computation and the inferences based on posterior samples. For a more detailed discussion of each method, see the corresponding papers.

## Likelihood

All three LBL methods share a similar formulation with differences arises from different designs. We first specify the formulation, and then introduce the parameters used in the likihood.

### LBL

Consider a case-control design with $n$ total individuals, all genetically independent of each other and ethnically homogeneous. For each individual $i$, let $G_i$ be the observed genotype, $Z_i$ be the unobserved halotype pair for the $i$-th individual, $Y_i$ be the binary case-control status of the $i$-th individual, then the complete retrospective likelihood is:

$$L_{cc}(\phi) \propto \prod_{i=1}^{n} P(Z_i \mid Y_i, \phi)P(G_i \mid Z_j) $$

where $\phi$ is a collection of parameters, including individual haplotype effect ($\beta$), haplotype frequencies ($\mathbf{f}$) and other hyperparameters.

### famLBL

For each family $i, i=1,2,\ldots,m$, each (affected child, father, mother) trio can be formualted as a "matched  pair". One pair of haplotypes consist of the haplotype of the offspring ($Z_{ic}$) -- the pair of haplotypes transmitted from the parents to the affected offspring. The other pair of haplotype ($Z_{iu}$) is the two haplotypes not transmitted from the parents to the offspring, and it can be considered as a pseudo control. And this pair  ($Z_{ic}$, $Z_{iu}$) form a matched pair design for each family. Similarly, let $G_{ic}$ and $G_{iu}$ be the corresponding genotypes transmitted or not transmitted. Let $Y_{ic}$ denote the disease status of the offspring ($Y_{ic} = 1$). Then, the likelihood can be formulated as,

$$L_{\mbox{fam}}(\phi) \propto \prod_{i=1}^m P(Z_{ic} \mid Y_{ic} =1 , \phi) (P(Z_{iu} \mid \phi)) P(G_{ic} \mid Z_{ic}) P(G_{iu} \mid Z_{iu}) $$

### cLBL

cLBL combines the independent case-control design and the case-parent triad design. Using notations above, for each independent individual $i$, let $G_i$ be the observed genotype, $Z_i$ be the unobserved halotype, $Y_i$ be the dichotomous case-control status. Suppose there are $n_1$ cases and $n-n_1$ controls, the likelihood function for the case-control portion can be specified as:

$$L_{cc}(\phi) \propto \prod_{i=1}^{n_1}P(Z_i|Y_i=1,\phi) \cdot \prod_{i=n_1+1}^{n}P(Z_i|Y_i=0,\phi) \prod_{i=1}^n P(Z_i \mid G_i)   $$

And the likelihood for the case-parent triad part can be specified as:

$$L_{fam}(\phi) \propto \prod_{i=1}^m P(Z_{ic} \mid Y_{ic} =1 , \phi) (P(Z_{iu} \mid \phi)) P(G_{ic} \mid Z_{ic}) P(G_{iu} \mid Z_{iu}) $$

And the joint likelihood for cLBL is :

$$ L_c(\phi) \propto L_{cc}(\phi) \times L_{fam}(\phi) $$

## Parameters

The aforementioned set of parameters $\phi$ include the following parameters:

* $\beta_j, j=1,2,\ldots,k-1$, the effect of haplotype $j$ compared to the baseline haplotype. This is the parameter of interests.

* $\alpha$, the effect of the baseline haplotype.

* $\mathbf{f} = (f_1,f_2,\ldots,f_m)$, the frequency distribution of all haplotypes present in the dataset.

* $Z = (Z_k,Z_{k'})$, the unobserved haplotype pair of an individual.

* $a_z$, the probability of an individual having haplotype pair $Z=(Z_k,Z_{k'})$.

* $d$, the inbreeding coefficient. $d=0$ would indicate the population is in Hardy-Weinberg Equilibrium. $d > 0$ would indicate an inbreeding populating and $d < 0$ indicate an outbreeding population.


Next we detail the parameters.

We connect $\beta_j$'s with the likelihood through a logistic model. let $\theta$ be the odds of disease given a specific haplotype pair $Z$ (i.e., $\theta=P(Y=1 \mid Z) / P(Y=0 \mid Z)$), then, we model the log odds ratio $\theta$ as,

$$\log \theta = \alpha + X\beta $$

where $X$ is a row vector and each $X$ is the design vector associated with haplotype pair $Z$, and $\alpha$ is log odds of the pre-selected baseline haplotype.

It is worth noting that each $\beta_i$ measures the effect of haplotype $i$ in contrast of the baseline haplotype. Therefore, choosing different baseline haplotypes might result in different $\beta$ values. Only selecting a baseline that is not associated with the disease (i.e., $\alpha = 0$) will yield a correct interpretation. Choosing a haplotype that is associated with the disease might lead to loss of power in detecting other associated haplotypes and false positives. Therefore, one needs to take extra care when choosing the baseline haplotype. One way to avoid such scenarios is to use different baseline haplotypes. By default, the most frequent haplotype is chosen as the baseline.


Let $\mathbf{f}= (f_1, f_2, \ldots, f_m)$ denote frequency distribution of $m$ distinct haplotypes. And let $a_z(\mathbf{f},d)$, the frequency of an individual with a specific haplotype pair $Z=(z_k,z_{k'})$ be modelled as:

$$a_z(\mathbf{f},d) = \left\{ \begin{array}
{rr}
f_k^2+df_k(1-f_k) & \mbox{if } z_k=z_{k'}  \\
2(1-d)f_k f_{k'} &  \mbox{if } z_k \neq z_{k'} \\
\end{array} \right.,
$$

where $d$ is the within-populatin inbreeding coefficient. 

## Priors{#sec:priors}

### $\beta$

To penalize unassociated haplotype effects, double exponential (Laplace) distribution is used as the prior distribution for each $\beta_j$,

$$\pi(\beta_j \mid \lambda) = \frac{\lambda}{2} \exp\left(-\lambda\mid\beta_j\mid\right)$$

The hyperparameter $\lambda$ controls the level of shrinkage. A larger value of $\lambda$ indicates more shrinkage.

### $\lambda$

Instead of picking a fixed $\lambda$, we let $\lambda$ follow a Gamma$(a,b)$ distribution with pdf

$$\pi(\lambda) = b^a\Gamma(a)^{-1} \lambda^{a-1} \exp{(-b\lambda)}$$

### $\mathbf{f}$ and $d$

For the parameters involved in frequency calculation, we use Dirichlet(1,1,...,1) distribution as the prior distribution for haplotype frequency distribution parameters $\mathbf{f}$. The prior distribution for the inbreeding coefficient $d$ is set as unif$(\max_k \lbrace-f_k/(1-f_k)\rbrace,1)$.

### $Z$

For each individual $i$, we assign discrete uniform priors to all haplotypes compatible with the observed genotype. Therefore during each iteration, the haplotype will get updated according to the likelihood of each compatible haplotype pair.

## Inferences on Posterior Samples {#sec:inference}

Once the Markov Chain has converged, one can carry out inference based on posterior samples. The package includes built-in functions for inference based on posterior samples of $\beta$, providing estimates for OR, CI and Bayes Factor.

### Bayes Factor

Bayes Factor is defined as the ratio between posterior odds and prior odds.

Since the prior and posterior distirbutions for all $\beta_i$'s are both continuous, we cannot directly calculate the prior or posterior odds of $|\beta_i| = 0$. So, we opt to test $H_0: |\beta_j| \le \epsilon$ where $\epsilon$ is a pre-defined a small number. The odds is calculated as $P(|\beta| > \epsilon) / P(|\beta| \leq \epsilon)$ for both posterior and prior distributions. Then BF is the ratio between the two odds.

If all posterior $\mid\beta_i\mid$ exceed $\epsilon$, then we set BF = 999 for computational considerations.

### OR and CI

We also provide an odds ratio (OR) estimate based on posterior sample mean and a 95% credible interval (CI) estimate based posterior samples.


# Using LBL

All three LBL algorithms take some common input (genotypes, phenotypes, starting parameters, etc). First we detail those parameters, and then we follow up with examples for all three algorithms with a simulated dataset.

## Data Input

LBL takes data in pedigree format, regardless of the type of the design. The objects should be either a matrix or a data frame, consisting of $n$ rows ($n$ = number of individuals) and $6 + 2\times p$ columns ($p$= number of SNPs). The first 6 columns of the data describe the pedigree relationship and the phenotype of the individual, and the last $2\times p$ columns describe the genotype information of the individual, with each marker taking up 2 columns. The genotype data can be either alphabetic or numeric.

The first 6 columns of the dataset should consist of:

- Family ID: A number denoting to which family this individual belongs. Related individuals should share the same family ID, while unrelated individuals should have different family IDs.
- Individual ID: The unique identifier of this individual. This ID should be unique within each family.
- Father ID: ID of the father of this individual. If the father is unknown, or the individual is a founder, then father ID = 0.
- Mother ID: ID of the mother of this individual. If the mother is unknown, or the individual is a founder, then mother ID = 0.
- Sex: the gender of an individual. Male =1 and female = 2.
- Phenotype: affection status of an individual. A case should have the value of 2 and a control should have the value of 1. Individuals with unknown status should have the value of 0 and they are treated as controls in the analysis.

More information about the format can be found [here](https://www.broadinstitute.org/haploview/input-file-formats).

The LBL package includes two example datasets: `fam` includes 20 case-parent trios, while `cac` includes 50 independent cases and 50 independent controls. Both datasets consist of 5 no-recombining SNPs. Below is a look of the beginning of these datasets.

```{r, echo=TRUE}
library(LBL)
data(cac)
data(fam)
head(fam)
head(cac)
```

## Other Parameters

There are some other parameters that need to be specified for the MCMC algorithm. They are:

- starting values: providing a starting values for the MCMC.

- a, b: the hyperparameters for $\lambda$, which controls the shrinkage effect of $\beta$. See [Priors](#sec:priors) section for details. Different values of $a$ and $b$ have some effect on the outcome, the details can be found in paper.

- e: the number $\epsilon$ used as a cutoff as if $\beta$ can be treated as 0. The default is 0.1. See [Inferences on Posterior Samples](#sec:Inferences on Posterior Samples) section for details.


## LBL

## cLBL

# Example

## LBL

```{r, echo=TRUE}
library(LBL)
head(cac)
set.seed(1)
LBL.obj<-LBLcac(cac,burn.in = 40000,num.it = 70000)
LBL.obj
print_LBL_summary(LBL.obj)
```


## famLBL

```{r, echo=TRUE}
library(LBL)
head(fam)
set.seed(1)
famLBL.obj<-LBLfam(fam,burn.in = 40000,num.it = 70000)
famLBL.obj
print_LBL_summary(famLBL.obj)
```


## cLBL

```{r, echo=TRUE}
library(LBL)
head(cac)
head(fam)
set.seed(1)
cLBL.obj<-LBLcombined(fam,cac,burn.in = 40000,num.it = 70000)
cLBL.obj
print_LBL_summary(cLBL.obj)
```





# References
